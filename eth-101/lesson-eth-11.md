# DAPP Front-end for our MemeCoin

Now for the fun part, let's create a front-end for our smart contract so we will be able to transfer coins, burn extra supply, and mint more if we needed to. I will be creating the front-end in React and using Ethers.js but you can use your favorite front-end framework. [Here](https://github.com/CadenaDev/memecoin-dapp-boilerplate) is a boilerplate to get started with and you can find the completed code for this lesson here. If you need a refresher on DAPPs, see our previous lesson [here](https://app.cadena.dev/lesson/ethereum-101/lesson-eth-8/8).

![](https://cadena.incl.us/wp-content/uploads/2021/12/meme-coin-dapp-cadena.png)



To help you get started quickly, you can fork the repo for the boilerplate React project [here](https://github.com/CadenaDev/bank-dapp-boilerplate) to run locally. Below is the final version of the code we will be writing together and as usual we will be breaking it down for you. 

**Note:** Because the file is long I've only included a snippet, you can find the completed code for the App.js file [here](https://gist.github.com/saeedjabbar/26378daf09a325666064eaf8ef2bebf9) and the completed project [here](https://github.com/CadenaDev/memecoin-dapp-completed). Before we begin, review the complete code to get a high level overview of what we're going to accomplish.

```javascript
import { useState, useEffect } from 'react';
import { ethers, utils } from "ethers";
import abi from "./contracts/MemeCoin.json";

function App() {
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [inputValue, setInputValue] = useState({ walletAddress: "", transferAmount: "", burnAmount: "", mintAmount: "" });
  const [tokenName, setTokenName] = useState("");
  const [tokenSymbol, setTokenSymbol] = useState("");
  const [tokenTotalSupply, setTokenTotalSupply] = useState(0);
  const [isTokenOwner, setIsTokenOwner] = useState(false);
  const [tokenOwnerAddress, setTokenOwnerAddress] = useState(null);
  const [yourWalletAddress, setYourWalletAddress] = useState(null);
  const [error, setError] = useState(null);

  const contractAddress = '0x3ACa50B150c180360F445C547BB11a8975760473';
  const contractABI = abi.abi;
  
  ....Get Completed File Here: https://gist.github.com/saeedjabbar/26378daf09a325666064eaf8ef2bebf9
```

## Setting Up Our Contract 

Before we dive into our code, let's think about the outcomes of our dapp. We want to burn out coins, transfer them, and mint additional tokens. 

```javascript
import { useState, useEffect } from 'react';
import { ethers, utils } from "ethers";
import abi from "./contracts/MemeCoin.json";
```

Now let's jump into the first 3 lines. In our first line we're pulling some hooks from react but line 2 and 3 are most important for us. Afrer installing the Ethers.js package we're importing ethers and [utlities](https://docs.ethers.io/v5/api/utils/) from the ethers library. Then finally we're going to be importing the JSON version of our contract that was generated by Hardhat. The steps to do so are as follows: 

1. Create a folder called `contract` in your React project `src` folder, paste over your MemeCoin.json file from our smart contract lesson in our Hardhat project. The file is found in `./artifacts/contracts/MemeCoin.sol/MemeCoin.json`. It's commonly reffered to as an Application Binary Interface (ABI) file and contains a JSON version of our contract that we can interface with.
2. Import your ABI file into your project using `import abi from "./contracts/MemeCoin.json";`

I'm going to breilfy explain what's happening here. The first item in the array is a state variable that we use to store values we will need to refer later using the React `useState()` [hook](https://reactjs.org/docs/hooks-state.html). The second item is a function that lets us change our state. The parameters of the `useState()` function are our default values i.e. our wallet connection status is set to false by default.

```javascript
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [inputValue, setInputValue] = useState({ walletAddress: "", transferAmount: "", burnAmount: "", mintAmount: "" });
  const [tokenName, setTokenName] = useState("");
  const [tokenSymbol, setTokenSymbol] = useState("");
  const [tokenTotalSupply, setTokenTotalSupply] = useState(0);
  const [isTokenOwner, setIsTokenOwner] = useState(false);
  const [tokenOwnerAddress, setTokenOwnerAddress] = useState(null);
  const [yourWalletAddress, setYourWalletAddress] = useState(null);
  const [error, setError] = useState(null);
```

Now for the important parts. Grab the address of your contract, this was given to you in Hardhat when you deployed your contract. In line 1 we create a variable to store the address of our contract. In line two we are grabbing the ABI file we imported using a reference variable and getting the actual ABI project off of it, then storing that in a varible called `contractABI`, take a look at your Bank.json file to see what I mean, or see [this screen shot](https://cadena.incl.us/wp-content/uploads/2021/12/abi.png) for a reference.

```javascript
const contractAddress = '0x3ACa50B150c180360F445C547BB11a8975760473';
const contractABI = abi.abi;
```

ðŸš¨**Note:** Everytime you make a change in your smart contract and deploy it, there will be a new address and ABI file generated. You have to copy over the new contract address and ABI file into your React project. If you find yourself pulling your hair out because your DAPP or smart contract isn't working, many times it's because you haven't updated your contract address and ABI to the latest versions.ðŸš¨

## Connecting to MetaMask 

Now we have to see if our user has an Ethereum wallet (in this case MetaMask) and if that wallet exists, connect it to our DAPP. It's the equivalent of using and connecting to an app with an Auth service provider like Facebook Connect. Without a wallet the user will not be able to fully interact with "web3".

 You can use a library like [Web3Modal](https://github.com/Web3Modal/web3modal) to connect to the most popular Ethereum Wallets but we're keeping this simple for this course. Note: Most of our functions are async since we're awaiting values to be returned.

```javascript
const checkIfWalletIsConnected = async () => {
  try {
    if (window.ethereum) {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
      const account = accounts[0];
      setIsWalletConnected(true);
      setYourWalletAddress(account);
      console.log("Account Connected: ", account);
    } else {
      setError("Install a MetaMask wallet to get our token.");
      console.log("No Metamask detected");
    }
  } catch (error) {
    console.log(error);
  }
}
```

Ethereum wallets usually come in the form of browser extensions and when installed will inject a global variable called ethereum into the window object. On `line 3` we check if ethereum is in the window object (window.ethereum) which means a wallet is likely present. On `line 4` we're making a request to get an array of metamask accounts and `line 5` we're grabbing the first account at index 0, which is the current connected account. On `line 6` we set our wallet is connected to true, which will render the web3 functionalities of our dapp that we gated. Then on `line 7` we store the wallet address of the current connected account.

`checkIfWalletIsConnected()` is being loaded as soon as our app loads via the useEffect() hook at line [147](https://gist.github.com/saeedjabbar/26378daf09a325666064eaf8ef2bebf9#file-app-js-L147).  You can read more details about this process in the official MetaMask [docs](https://docs.metamask.io/guide/getting-started.html#basic-considerations).

## Getter Functions

```javascript
  const getTokenInfo = async () => {
    try {
      if (window.ethereum) {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const tokenContract = new ethers.Contract(contractAddress, contractABI, signer);
        const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' });

        let tokenName = await tokenContract.name();
        let tokenSymbol = await tokenContract.symbol();
        let tokenOwner = await tokenContract.owner();
        let tokenSupply = await tokenContract.totalSupply();
        tokenSupply = utils.formatEther(tokenSupply)

        setTokenName(`${tokenName} ðŸ¦Š`);
        setTokenSymbol(tokenSymbol);
        setTokenTotalSupply(tokenSupply);
        setTokenOwnerAddress(tokenOwner);

        if (account.toLowerCase() === tokenOwner.toLowerCase()) {
          setIsTokenOwner(true)
        }
      }
    } catch (error) {
      console.log(error);
    }
  }
```

Now let's look at the first of our getter functions. Remember calling a getter fuction is free, as it costs no gas to do so since it's read only. Again we're checking if the ethereum object is present at `line 3`. Let's break down lines 4 through 9. 

```javascript
const provider = new ethers.providers.Web3Provider(window.ethereum);
```

A provider lets us connect to the ethereum blockchain, in this case the Rinkeby testnet via an ethereum node. We're using MetaMask's provider which uses [Infura](https://infura.io/) behind the scenes. You can read more about providers [here](https://docs.ethers.io/v5/api/providers/#:~:text=A%20Provider%20is%20an%20abstraction,to%20standard%20Ethereum%20node%20functionality.). It's important to know providers can only complete read only actions.

![Credit: StackExchange](https://cadena.incl.us/wp-content/uploads/2021/12/providers.png)

```javascript
const signer = provider.getSigner();
```

Now with our provider we get a signer which is an abstraction of your MetaMask wallet that lets you interact with the blockchain without revealing your private keys. As a signer, you can write to the ethereum blockchain via transactions. You can read more on signers [here](https://docs.ethers.io/v5/api/signer/#:~:text=A%20Signer%20in%20ethers%20is,on%20the%20sub%2Dclass%20used.).

```javascript
const tokenContract = new ethers.Contract(contractAddress, contractABI, signer);
```

Next we get our contract using our contract address, the ABI file, and a signer.

```javascript
const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' });
```

We're then pulling the first account from MetaMask.

```javascript
let tokenName = await tokenContract.name();
let tokenSymbol = await tokenContract.symbol();
let tokenOwner = await tokenContract.owner();
let tokenSupply = await tokenContract.totalSupply();
tokenSupply = utils.formatEther(tokenSupply)

setTokenName(`${tokenName} ðŸ¦Š`);
setTokenSymbol(tokenSymbol);
setTokenTotalSupply(tokenSupply);
setTokenOwnerAddress(tokenOwner);
```

In lines `1 - 4` we're pulling our token name, symbol, the owner of the token and the total supply. In `line 5` we get this suppy and then format it so that it is readable for our users.

Then right after we're using our setter functions to set our initial state variables to these new values so they can be rendered into our app. I added an emoji for my token name as an extra touch and to save some gas. Remember these functions were inherited via [OpenZeppelin](https://docs.openzeppelin.com/contracts/2.x/api/utils). 	

```javascript
if (account.toLowerCase() === tokenOwner.toLowerCase()) {
  setIsTokenOwner(true)
}
```

What we're doing here is checking if the connected account is the token owner. If that is the case, they will unlock the functionality in our DAPP to burn tokens and mint new ones.

## Setter Functions 

We're using 3 setter fuctions in our code, `transferToken()` to send tokens to our friends, `burnTokens()` and `mintTokens()` so that we can control the supply of our tokens.

```javascript
const transferToken = async (event) => {
  event.preventDefault();
  try {
    if (window.ethereum) {
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();
      const tokenContract = new ethers.Contract(contractAddress, contractABI, signer);
      
      const txn = await tokenContract.transfer(inputValue.walletAddress, utils.parseEther(inputValue.transferAmount));
      console.log("Transfering tokens...");
      await txn.wait();
      console.log("Tokens Transfered", txn.hash);

    } else {
      console.log("Ethereum object not found, install Metamask.");
      setError("Install a MetaMask wallet to get our token.");
    }
  } catch (error) {
    console.log(error);
  }
}
```

Remember setter functions cost gas and requires a signer to initiate it. We've covered lines 4 through 7 but I quickly want to touch on line 2 for those who aren't familiar with React. `event.preventDefault() ` prevents our dapp from reloading everytime we submit our form. 

Remember when you created your MemeCoin contract, you sent your self the initial supply of tokens. `Line 8` lets us send tokens to our friends using the `transfer()` function, all we need is their address and the amount we want to send for our parameters.

```javascript
const txn = await tokenContract.transfer(inputValue.walletAddress, utils.parseEther(inputValue.transferAmount));
console.log("Transfering tokens...");
await txn.wait();
console.log("Tokens Transfered", txn.hash);
```

Then we just wait for our Tokens to be transferred, note that it can take some time for the transaction to resolve, even on a testnet. You can use [Remix](https://remix.ethereum.org/), to speed things up. Then finally once our transaction is resolved, we `console.log` the hash which you can put in Etherscan to see the details of your transaction. 

## Burning Tokens

You might have heard of burning tokens and minting tokens, this has spawned the entire field of "Tokenomics". As the name implies burning a token destroys it for good. Depending on your needs you can control the inflation and deflation rates of your tokens. You can even burn a token to mint a new one, like Terra burns Luna to create UST (a stable coin), see [here](https://www.yahoo.com/now/terraform-labs-set-initiate-burn-030000395.html#:~:text=SEOUL%2C%20South%20Korea%2C%20Nov.,(depending%20on%20its%20price).) for more.  

```javascript
const txn = await tokenContract.burn(utils.parseEther(inputValue.burnAmount));
console.log("Burning tokens...");
await txn.wait();
console.log("Tokens burned...", txn.hash);

let tokenSupply = await tokenContract.totalSupply();
tokenSupply = utils.formatEther(tokenSupply)
setTokenTotalSupply(tokenSupply);

```

To keep things concise we're just grabbing the important lines from our contract. In `line 1` we're calling the burn function from the OpenZeppelin Burnable library in our contract. On `line 5`, right after our tokens are burned we get the new total supply of our token then update our token supply to the new total and format it into a readable number using `utils.formatEther()`.

## Minting Tokens

Perhaps our token is going viral and there is so much demand, we need to print more, then we can mint new tokens.

```javascript
const tokenContract = new ethers.Contract(contractAddress, contractABI, signer);
let tokenOwner = await tokenContract.owner();
const txn = await tokenContract.mint(tokenOwner, utils.parseEther(inputValue.mintAmount));
console.log("Minting tokens...");
await txn.wait();
console.log("Tokens minted...", txn.hash);

let tokenSupply = await tokenContract.totalSupply();
tokenSupply = utils.formatEther(tokenSupply)
setTokenTotalSupply(tokenSupply);
```

On `line 3` we call the `mint()` [function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252) which comes out of the box with OpenZeppelin which actually checks to see if we're the owner of the contract before we can mint more by taking in the contract owner's address as a parameter, followed by the amount we want to mint. We use `parseEther` here to reverse it back to Wei (10*18).  After our transaction is finished, we then wait for the new supply, format it as a readable number and update our token supply.

## Wrapping Up

```javascript
  const handleInputChange = (event) => {
    setInputValue(prevFormData => ({ ...prevFormData, [event.target.name]: event.target.value }));
  }
  
  useEffect(() => {
    checkIfWalletIsConnected();
    getTokenInfo();
  }, [])
```

`handleInputChange()` lets us grab the value from our form inputs and pass it to our handler functions. `useEffect()` is a react [hook](https://reactjs.org/docs/hooks-effect.html) that loads up all of our functions when the dapp first loads. We're using it to check if the user has a wallet and then load the data for our token. The remaining HTML with the styling and handler functions can be found [here](https://gist.github.com/saeedjabbar/26378daf09a325666064eaf8ef2bebf9).

Give yourself a huge congratulations for making it this far ðŸŽ‰ You've minted your very first meme coin, and who knows may be it will be worth something one day!

